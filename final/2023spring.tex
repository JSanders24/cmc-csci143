\documentclass[12pt]{exam}
\usepackage[utf8]{inputenc}

\usepackage[normalem]{ulem}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage[shortlabels]{enumitem}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = black, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor    = blue  %Colour of citations
}

\usepackage{multirow}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\usepackage[table]{xcolor}
\usepackage{color}
\usepackage{colortbl}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{gray}{rgb}{0.7,0.7,0.7}

\usepackage{listings}
\lstset {
	basicstyle=\ttfamily,
    ,language=SQL
    ,showstringspaces=false
    ,keepspaces=true
}

\usepackage {tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning}
\definecolor {processblue}{cmyk}{0.96,0,0,0}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% question definitions

%\printanswers

\newcommand*{\hl}[1]{\colorbox{yellow}{#1}}

\newcommand*{\answerLong}[2]{
    \ifprintanswers{\hl{#1}}
\else{#2}
\fi
}

\newcommand*{\answer}[1]{\answerLong{#1}{~}}

\newcommand*{\TrueFalse}[1]{%
\ifprintanswers
    \ifthenelse{\equal{#1}{T}}{%
        \hl{\textbf{TRUE}}\hspace*{14pt}False
    }{
        True\hspace*{14pt}\hl{\textbf{FALSE}}
    }
\else
    {True}\hspace*{20pt}False
\fi
} 
%% The following code is based on an answer by Gonzalo Medina
%% https://tex.stackexchange.com/a/13106/39194
\newlength\TFlengthA
\newlength\TFlengthB
\settowidth\TFlengthA{\hspace*{1.3in}}
\newcommand\TFQuestion[2]{%
    \setlength\TFlengthB{\linewidth}
    \addtolength\TFlengthB{-\TFlengthA}
    \parbox[t]{\TFlengthA}{\TrueFalse{#1}}\parbox[t]{\TFlengthB}{#2}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\theoremstyle{definition}
\newtheorem{problem}{Problem}
\newcommand{\E}{\mathbb E}
\newcommand{\R}{\mathbb R}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\newcommand{\trans}[1]{{#1}^{T}}
\newcommand{\loss}{\ell}
\newcommand{\w}{\mathbf w}
\newcommand{\x}{\mathbf x}
\newcommand{\y}{\mathbf y}
\newcommand{\ltwo}[1]{\lVert {#1} \rVert}

\newcommand{\ignore}[1]{}

\usepackage{listings}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
stepnumber=1,
numbers=left
}}

\lstnewenvironment{python}[1][]
{
    \pythonstyle
    \lstset{#1}
}
{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{center}
    {
\Large
    CSCI143 Final, Spring 2023
}

    \vspace{0.1in}
\end{center}

\noindent
\textbf{Collaboration policy:} 

\vspace{0.1in}
\noindent
You may NOT:
\begin{enumerate}
    \item discuss the exam with any human other than Mike; this includes:
        \begin{enumerate}
            \item asking your friend for clarification about what a problem is asking
            \item asking your friend if they've completed the exam
            \item posting questions to github
        \end{enumerate}
\end{enumerate}

\noindent
You may:
\begin{enumerate}
    \item take as much time as needed
    \item use any written notes / electronic resources you would like
    \item use the lambda server
    \item ask Mike to clarify questions via email
\end{enumerate}


\vspace{0.15in}

\vspace{0.25in}
\noindent
Name: 

\noindent
\rule{\textwidth}{0.1pt}
\vspace{0.15in}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
%\section{True/False Questions}

%For each question below, circle either True or False.
%Each correct answer will result in +2 points,
%each incorrect answer will result in -2 points,
%and each blank answer in 0 points.

%\begin{questions}
%\question\TFQuestion{F}{A table that takes up 832KB on disk has 104 pages.}
%\question\TFQuestion{F}{A denormalized representation of data tends to take up less disk space than a normalized representation.}
%\question\TFQuestion{T}{An index only scan may have to access heap table pages to determine whether a tuple is visible.  This is likely to happen on a table that has had many recent UPDATE/DELETE operations and no recent VACUUM operation.}
%\question\TFQuestion{T}{A btree index created on an INTEGER column will have a larger fanout than a btree index created on a BIGINT column.}
%\question\TFQuestion{F}{Every heap page must have at least one live tuple.}
%\question\TFQuestion{F}{If you run the TRUNCATE command to delete the contents of a table, you must run a subsequent VACUUM FULL command to free up the disk space for other processes to use.}
%\question\TFQuestion{T}{Postgres automatically compresses large TEXT values.}
%\question\TFQuestion{F}{Postgres documentation recommends disabling autovacuum if you encounter the transaction id wraparound problem.}
%\question\TFQuestion{T}{Decreasing the \lstinline{fillfactor} for a table from the default value of 100 will make HOT tuple updates more likely.}
%\question\TFQuestion{F}{The autovacuum process runs the VACUUM FULL command at regular intervals in order to automatically free up disk space from dead tuples.}
%\question\TFQuestion{T}{A btree index created on an SMALLINT column will have higher fanout than the same index created on a BIGINT column.}
%%\question\TFQuestion{T}{Both heap tables and indexes can have a free space map file.}
%\question\TFQuestion{F}{In the postgres documentation, TID is an abbreviation for transaction identifier.}
%\question\TFQuestion{F}{Dirty reads are possible in Postgres's read committed isolation level.}
%%\question\TFQuestion{F}{If a tuple exists on disk, there is guaranteed to be some transaction that can see the tuple.}
%%\question\TFQuestion{F}{Postgres's btree indexes contain metainfo in order to determine tuple visibility for index only scans.}
%\question\TFQuestion{T}{For very small tables, the postgres query planner is likely to choose sequential scan instead of an index scan.}
%\question\TFQuestion{T}{The hash index supports the bitmap scan access method.}
%\question\TFQuestion{T}{A database stored using HDDs should have a higher value for the \lstinline{random_page_cost} system parameter than a database stored using SSDs.}
%\question\TFQuestion{F}{A denormalized representation of data tends to take up less disk space than a normalized representation.}
%\question\TFQuestion{T}{The nested loop join strategy can be used to join tables on an equality constraint.}
%\question\TFQuestion{T}{The hash join strategy can be used for self joins.}
%%\question\TFQuestion{T}{The HashAggregate strategy can be}

%\question\TFQuestion{T}{A hash index can be used to speed up a nested loop join.}
%\question\TFQuestion{F}{A btree index can be used to speed up a CHECK constraint.}
%\question\TFQuestion{F}{It is possible to INSERT a NULL value into a column labeled as the PRIMARY KEY.}
%\question\TFQuestion{F}{It is not possible to create a GIN index to enforce a UNIQUE constraint, but it is possible to create a RUM index to enforce a UNIQUE constraint.}
%\question\TFQuestion{T}{One advantage of the RUM index over the GIN index is that the former supports index scans and the latter does not.  This implies that the RUM index can be used to speed up queries using the \lstinline{LIMIT} clause, but the GIN index cannot.}
%\question\TFQuestion{F}{If postgres crashes while a DELETE/INSERT/UPDATE statement is modifying a RUM index, the index becomes corrupted and must be regenerated.}
%\question\TFQuestion{T}{The ANALYZE command collects statistics on the values in the table which the query planner uses when selecting which scan algorithm to use for a query.}
%%\question\TFQuestion{T}{It's always possible to use a nested loop join.}
%\question\TFQuestion{F}{A hash index can return tuples in sorted order.}
%\question\TFQuestion{T}{The GroupAggregate algorithm can be used if one of the SELECT columns contains COUNT(DISTINCT *).}
%\question\TFQuestion{F}{When a table has been CLUSTERed on an index, inserting new tuples causes them to be inserted in the order specified by the index.}
%%\question\TFQuestion{T}{In postgres, the INSERT command will never block a SELECT command, and the SELECT command will never block the INSERT command.}
%\question\TFQuestion{F}{In the current version of postgres (versrion 14), index only scans can be parallelized, but index scans cannot be parallelized.}
%\question\TFQuestion{F}{If you run EXPLAIN ANALYZE on an UPDATE statement, then the database is guaranteed not to modify your data.}
%\question\TFQuestion{F}{The order of columns matters in a multi-column GIN index.}
%%\question\TFQuestion{T}{Given the string ``C\'esar Ch\'avez'', an NFD-normalized UTF-8 encoding will require more bytes than a NFKC-normalized UTF-8 encoding.}
%%\question\TFQuestion{F}{The UTF-16 encoding cannot represent NFKD-normalized text.}
%%\question\TFQuestion{F}{The TSVECTOR type can be created on NFC normalized TEXT fields, but cannot be created on NFD normalized TEXT fields.}
%%\question\TFQuestion{T}{Given any string in NFKC form, normalizing to NFC and back to NFKC is guaranteed to be an idempotent operation (i.e. you will get the same string back.)}

%\end{questions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
%\section{Integrated Questions}

\newpage
\noindent
The questions below relate to the following simplified normalized twitter schema.

\begin{lstlisting}
CREATE TABLE users (
    id_users BIGINT PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    description TEXT
);

CREATE TABLE tweets (
    id_tweets BIGINT PRIMARY KEY,
    id_users BIGINT REFERENCES users(id_users),
    created_at TIMESTAMPTZ CHECK (created_at > '2000-01-01'),
    country_code VARCHAR(2) NOT NULL,
    lang VARCHAR(2) NOT NULL,
    text TEXT NOT NULL
);

CREATE TABLE tweet_tags (
    id_tweets BIGINT,
    tag TEXT,
    PRIMARY KEY (id_tweets, tag),
    FOREIGN KEY (id_tweets) REFERENCES tweets(id_tweets)
);
\end{lstlisting}

\begin{questions}
\question{
    (8pts)
    Recall that certain constraints create indexes on the appropriate columns.  List the equivalent CREATE INDEX commands that are run by the constraints above.
}

\begin{solution}
\end{solution}

\newpage
\question{
(8pts)
Create index(es) so that the following query will run as efficiently as possible.
Do not create any unneeded indexes.

HINT:
Pay careful attention to the column list.

\begin{lstlisting}
SELECT DISTINCT tag
FROM tweet_tags
WHERE
    lower(tag) LIKE 'corona%';
\end{lstlisting}
}

\begin{solution}
\end{solution}

\newpage
\question{
(16pts)
Consider the following two queries,
which differ only by the conjunction operation used in the WHERE clause.

For each query:
    (1) Create index(es) so that the query will run as efficiently as possible.
    (2) State which scanning strategy you expect the Postgres query planner will use and explain why.
    (3) Describe which clauses of the query will be sped up with the table scanning strategy you selected in (2), and which clauses (if any) will not be sped up.

HINT:
One of these queries can be implemented very efficiently with an index only scan,
and the other query cannot.

\begin{enumerate}[a.]
    \item
\begin{lstlisting}
SELECT id_tweets
FROM tweets
WHERE country_code = :country_code
  AND lang = :lang
ORDER BY created_at
LIMIT 10;
\end{lstlisting}

\newpage
\item
\begin{lstlisting}
SELECT id_tweets
FROM tweets
WHERE country_code = :country_code
   OR lang = :lang
ORDER BY created_at
LIMIT 10;
\end{lstlisting}
\end{enumerate}
}
\begin{solution}
\end{solution}


\newpage
\question{
(8pts)
Create index(es) so that the following query will run as efficiently as possible.
Do not create any unneeded indexes.

\begin{lstlisting}
SELECT count(*)
FROM tweets
JOIN tweet_tags USING (id_tweets)
WHERE
    tag = :tag;
\end{lstlisting}
}


\newpage
\question{
(8pts)
Create index(es) so that the following query will run as efficiently as possible.
Do not create any unneeded indexes.

\begin{lstlisting}
SELECT name, count(*)
FROM users
JOIN tweets USING (id_users)
JOIN tweet_tags USING (id_tweets)
WHERE tag = :tag
GROUP BY name;
\end{lstlisting}
}

\begin{solution}
\end{solution}

\newpage
\question{
(16pts)
The following query returns tweets where either the text or the description of the user match a full text search query.

\begin{lstlisting}
SELECT id_tweets
FROM tweets, users
WHERE ( to_tsvector('english', text)
     || to_tsvector('english', description)
      ) 
      @@ to_tsquery('english', :query);
\end{lstlisting}
}

\begin{enumerate}[a.]
    \item This query cannot be sped up using an index.  Why?

        \begin{solution}
        \end{solution}

        \newpage
    \item Rewrite the query above into an equivalent query that can be sped up with an index.  Also provide the index that would speed up the query and explain why the modified query can be sped up.

        \begin{solution}
        \end{solution}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{questions}

\end{document}
